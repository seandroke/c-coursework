Sean DrokeCIS 3207Project 1 - Giorgio’s Discrete Event Simulator	The Discrete Event Simulator implemented in “eventsim.c” utilizes several data structures throughout the standard run of the program. The main structures used throughout consist of a priority queue and a FIFO queue and the focus of these two structures is to maintain a set of resource servers to allow for a continuous flow of “tasks” or information sets to be appended and removed from one server to another throughout a particular range of time.	C does not inherently allow for the dynamic increase in variable size without explicit memory allocation and deallocation on the user end. Due to this, creating either of the structure types above would yield less than ideal results with a standard array implementation. As a result of this, the simulator features a linked list structure. A linked list does not require a preset size and therefore can be continuously resized to reach whatever the program desires, at the expense of memory usage. This linked list structure is used in both the FIFO queue and the Priority queue as well as the various functions used to print simulator statistics.	The linked list structures used throughout this program are based on a set of structs defined at the very beginning. The primary struct definitions that maintain the essential functions of the simulator are that of an “event” and a “node”. The event contains relevant information pertaining to each individual task that the simulator will allow to loop throughout the system. The event contains a time, calculated internally using a constantly updating variable, a job number that will remain an identification value for a task, a type, and the disk assignment the task receives for I/O processing should that be required. This event can be a part of a node. A node contains an event or a job as well as a “link” to the next node in the sequence, should that exist. In doing this, a list is created as appendages are made to the node and the node’s next value.	With this linked list structure, the foundational queues can be created for the CPU, Disk 1, Disk 2, and the event priority queue, without ever explicitly having knowledge of what the size of this data might become. In each of the FIFO queues a sequence of nodes represent the list structure and the job’s that are members of each of those nodes are those that are being processed by each respective server. Should a job be present in a server’s queue, that job is waiting to be processed. Once processed, the event is removed from the queue effectively being freed from that linked list. The event priority queue works in a similar way, but because this queue contains every event the system processes, it must retain a method of ensuring each job is fairly distributed to its destination server in the correct order. Jobs in the FIFO queue are waiting for server components and jobs in the event queue are waiting to be sent to wait for those same components.	With these structures, the main sequence or driver of the program is best understood. For all of the elements in the event queue, they are distributed to each server queue. The respective server processes each of these elements, determines the next server the task should be sent to or not sent to, and the loop continues. An event could accomplish a variety of tasks. An event could arrive at the CPU, depart the CPU, arrive at either of the two disks, depart from them, or exit the system entirely. In each of these scenarios, the program performs a different set of steps to process each queue correctly. These events are logged to an external text file for review. The structure of this file is a new task printed on each individual line down the page, with the very bottom containing some statistics about the entire discrete run.	The program is complete when a maximum time, relative to the simulation, is reached. Jobs not finished, remain in the queues, they will be noticed in the log file as having an arrival characteristic but no defined completion. Calculated at the end are a series of computations related to queue statistics. These are calculated primarily using the same linked list data sequence applied to different structs. These structs contain essential information for these calculations and are constantly updated throughout the execution of the program such that at completion, they are completely accurate.	Choosing a linked list as the primary method of retaining queues was a difficult task as pointer implementation can become disorganized but the overall simplicity of not having to adjust for data size variations was worth the extra effort. In addition, to validate the effectiveness of this strategy, a test case was produced to manually populate and remove values from the priority queue before a loop is ever introduced and the logic behind the method proved sound. In the end, the program effectively produces a looped, random event sequence with several functional queues, as designed.